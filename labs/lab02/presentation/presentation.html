<h2 id="цель-работы">Цель работы</h2>
<p>Изучить и реализовать на языке Julia[1] методы символьного шифрования
на примере Маршрутного шифра[2], Решётчатого шифра[3] и шифра
Виженера[4].</p>
<h2 id="задачи">Задачи</h2>
<ol type="1">
<li>Ознакомиться с принципами построения маршрутного и решётчатого
шифров.</li>
<li>Реализовать классический шифр Виженера.</li>
<li>Освоить работу с двумерными матрицами и символьными строками в
Julia.</li>
<li>Провести тестирование алгоритмов.</li>
</ol>
<h2 id="объект-и-предмет-исследования">Объект и предмет
исследования</h2>
<p>Объект исследования: классические методы шифрования текста.</p>
<p>Предмет исследования: алгоритмы маршрутного, решетчатого и шифра
Виженера, их реализация средствами Julia.</p>
<h2 id="условные-обозначения-и-термины">Условные обозначения и
термины</h2>
<p>Маршрутный шифр — метод шифрования, при котором текст вписывается в
таблицу построчно, а затем считывается по определённому маршруту
(например, по столбцам).</p>
<p>Решётчатый шифр — метод шифрования, при котором символы записываются
через «маску-решётку», которая поворачивается на 90° и позволяет
постепенно заполнить всю таблицу.</p>
<p>Шифр Виженера — полиалфавитный шифр, использующий ключевое слово для
последовательного смещения символов текста.</p>
<h2
id="техническое-оснащение-и-выбранные-методы-проведения-работы">Техническое
оснащение и выбранные методы проведения работы</h2>
<p>Программное обеспечение:</p>
<ul>
<li>Язык программирования Julia.</li>
<li>Среда разработки JupyterLab / VS Code.</li>
</ul>
<p>Методы:</p>
<ul>
<li>Формирование двумерных массивов символов.</li>
<li>Использование арифметики по модулю для циклического сдвига
символов.</li>
<li>Работа с символьными данными в циклах</li>
</ul>
<h2 id="теоретическое-введение">Теоретическое введение</h2>
<p>Все три метода относятся к классическим подстановочным или маршрутным
шифрам:</p>
<ul>
<li><p>Маршрутный шифр демонстрирует важность выбора порядка считывания
данных из матрицы.</p></li>
<li><p>Решётчатый шифр основан на повороте ключевой «маски», что
позволяет равномерно распределять текст.</p></li>
<li><p>Шифр Виженера является развитием идеи шифра Цезаря: он использует
несколько алфавитов, задаваемых ключевым словом, что делает криптоанализ
более сложным.</p></li>
</ul>
<h2 id="задание">Задание</h2>
<ol type="1">
<li>Реализовать все три шифра из задания лабораторной работы №2.</li>
</ol>
<h2 id="маршрутный-шифр">Маршрутный шифр</h2>
<p>Выполним задание 1 с помощью языка Julia:</p>
<pre><code>function route_cipher(text::String, rows::Int, cols::Int)
    grid = [ &#39; &#39; for _ in 1: rows, _ in 1: cols]
    idx = 1
    for i in 1: rows
        for j in 1: cols
            if idx &lt;= lastindex(text)
                grid[i,j] = text[idx]
                idx += 1
            end
        end
    end
    chars = [grid[i,j] for j in 1:cols for i in 1: rows]
    return String(chars)
end
println(route_cipher(&quot;Helloworld&quot;, 4, 4))</code></pre>
<h2 id="маршрутный-шифр-1">Маршрутный шифр</h2>
<p>Проверим результат работы кода: См. <a href="#fig:001">рис. 1</a></p>
<figure id="fig:001">
<img src="1.png" style="width:70.0%" alt="Маршрутный шифр" />
<figcaption aria-hidden="true">Маршрутный шифр</figcaption>
</figure>
<h2 id="маршрутный-шифр-2">Маршрутный шифр</h2>
<p>Данный алгоритм является простейшей формой маршрутного шифрования. Он
работает по принципу “запись по строкам - чтение по столбцам”. Сначала
исходный текст построчно записывается в таблицу заданного размера (rows
× cols). Если текст короче общего размера таблицы, оставшиеся ячейки
заполняются пробелами.</p>
<p>Ключевыми параметрами шифра являются размеры таблицы (количество
строк и столбцов). Для расшифровки получатель должен знать эти
параметры, чтобы восстановить исходную таблицу и прочитать сообщение в
правильном порядке - по строкам.</p>
<h2 id="шифр-с-помощью-решётки">Шифр с помощью решётки</h2>
<p>Выполним задание 2 с помощью языка Julia:</p>
<pre><code>function grille_cipher(text::String, k::Int)
    n = 2*k
    grid = [ &#39; &#39; for _ in 1: n, _ in 1: n]
    idx = 1
    for rot in 0:3
        for i in 1:k, j in 1:k
            if idx &lt;= lastindex(text)
                if rot == 0
                    x, y = i,j
                elseif rot == 1
                    x, y = j, n - i + 1
                elseif rot == 2
                    x, y = n - i + 1, n - j + 1
                else
                    x, y = n - j + 1, i
                end
                grid[x,y] = text[idx]
                idx += 1
            end
        end
    end
    chars = [grid[i,j] for i in 1:n for j in 1: n]
    return String(chars)
end
println(grille_cipher(&quot;dogovorpodpisali&quot;, 2))     </code></pre>
<h2 id="шифр-с-помощью-решётки-1">Шифр с помощью решётки</h2>
<p>Проверим результат работы кода: См. <a href="#fig:002">рис. 2</a></p>
<figure id="fig:002">
<img src="2.png" style="width:70.0%" alt="Решётчатый шифр" />
<figcaption aria-hidden="true">Решётчатый шифр</figcaption>
</figure>
<h2 id="шифр-с-помощью-решётки-2">Шифр с помощью решётки</h2>
<p>Данный алгоритм использует принцип механической решетки с отверстиями
для шифрования. Ключом является параметр k, определяющий размер
квадратной таблицы (n × n, где n = 2k) и расположение “отверстий” - в
данном случае это все ячейки меньшего квадрата k × k в левом верхнем
углу. Процесс шифрования состоит из четырех этапов, соответствующих
поворотам решетки на 0°, 90°, 180° и 270°.</p>
<p>На каждом этапе символы исходного текста последовательно записываются
в те ячейки таблицы, которые оказываются под отверстиями решетки в
текущем положении. После записи каждой порции символов решетка
поворачивается на 90 градусов по часовой стрелке, что позволяет
равномерно распределить текст по всей таблице. После четырех поворотов
таблица полностью заполняется, а шифртекст образуется путем построчного
чтения всех ячеек.</p>
<p>Для расшифровки получатель должен иметь решетку с идентичными
отверстиями и, зная значение k, повторить ту же последовательность
поворотов, но уже читая символы из соответствующих позиций.</p>
<h2 id="таблица-виженера">Таблица Виженера</h2>
<p>Выполним задание 3 с помощью языка Julia:</p>
<pre><code>function vigenere_encrypt(text:: String, key::String)
    result = IOBuffer()
    keylen = length(key)
    for (i,c) in enumerate(text)
    if &#39;a&#39; &lt;= c &lt;= &#39;z&#39;
            t = Int(c) - Int(&#39;a&#39;)
            k = Int(key[(i-1) % keylen + 1]) - Int(&#39;a&#39;)
            enc = Char((t+k)% 26 + Int(&#39;a&#39;))
            print(result, enc)
        elseif &#39;A&#39;&lt;= c &lt;= &#39;Z&#39;
            t = Int(c) - Int(&#39;A&#39;)
            k = Int(key[(i-1) % keylen + 1]) - Int(&#39;a&#39;)
            enc = Char((t+k)% 26 + Int(&#39;A&#39;))
            print(result, enc)
        else 
            print(result,c)
        end
    end
    return String(take!(result))
end
println(vigenere_encrypt(&quot;cryptographyissecrecy&quot;, &quot;math&quot;))   </code></pre>
<h2 id="таблица-виженера-1">Таблица Виженера</h2>
<p>Проверим результат работы кода: См. <a href="#fig:003">рис. 3</a></p>
<figure id="fig:003">
<img src="3.png" style="width:70.0%" alt="Таблица Виженера" />
<figcaption aria-hidden="true">Таблица Виженера</figcaption>
</figure>
<h2 id="таблица-виженера-2">Таблица Виженера</h2>
<p>Шифр Виженера является полиалфавитным шифром, что означает
использование разных алфавитов для шифрования различных символов
исходного текста. Основой алгоритма служит ключевое слово, которое
циклически повторяется для сопоставления с каждой буквой шифруемого
сообщения. Процесс шифрования заключается в применении операции сложения
по модулю 26 к числовым значениям символов текста и ключа.</p>
<p>Для каждой буквы исходного текста определяется соответствующая буква
ключа (с циклическим повторением), затем вычисляется сдвиг в алфавите
как сумма позиций буквы текста и буквы ключа. Полученный результат по
модулю 26 дает позицию зашифрованного символа. Алгоритм сохраняет
регистр символов: строчные буквы шифруются в строчные, прописные - в
прописные, а не-буквенные символы остаются без изменений.</p>
<p>Данный метод обеспечивает высокую криптостойкость по сравнению с
моноалфавитными шифрами, поскольку одна и та же буква исходного текста
может быть зашифрована разными способами в зависимости от своей позиции
в сообщении. Для расшифровки требуется точное ключевое слово, чтобы
выполнить обратную операцию вычитания по модулю 26.</p>
<h2 id="полученные-результаты">Полученные результаты</h2>
<ol type="1">
<li><p>Реализованы функции для маршрутного шифра, решётчатого шифра и
шифра Виженера.</p></li>
<li><p>Проверена корректность работы алгоритмов на тестовых
строках.</p></li>
</ol>
<h2 id="заключение">Заключение</h2>
<p>В работе были изучены три различных метода шифрования. Получены
навыки работы с двумерными таблицами и полиалфавитными шифрами. Практика
показала, что даже простые алгоритмы могут эффективно изменять структуру
текста, делая его нечитаемым без ключа.</p>
<h2 id="библиографическая-справка">Библиографическая справка</h2>
<p>[1] Julia: https://ru.wikipedia.org/wiki/Julia</p>
<p>[2] Маршрутное шифрование:
https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%88%D0%B8%D1%84%D1%80</p>
<p>[3] Шифрование с помощью решетки:
https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D1%88%D1%91%D1%82%D0%BA%D0%B0</p>
<p>[4] Таблица Виженера:
https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%92%D0%B8%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B0</p>
